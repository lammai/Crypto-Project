import java.math.BigInteger;

public class E521 {

    /** Created for Keccak | E521 | Equation -> (x^2) + (y^2) = 1 + d(x^2)(y^2)
     *
     * (1) NIST Documentation: https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf
     * (2) Elliptic Curve Slides (canvas): https://canvas.uw.edu/courses/1555586/files/91632405?wrap=1
     * (3) https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc
     * (4) https://eprint.iacr.org/2013/647.pdf
     * (5) https://fse.studenttheses.ub.rug.nl/10478/1/Marion_Dam_2012_WB_1.pdf
     * ()
     */

    /** Elliptic X-Coordinate */
    private BigInteger X;
    /** Elliptic Y-Coordinate */
    private BigInteger Y;
    /** Elliptic curve initialization of D = -376014 */
    private BigInteger D = new BigInteger("-376014");
    /** Finite Field defined as of Mersenne prime????  */
    private BigInteger P = new BigInteger("2").pow(521).subtract(BigInteger.ONE);
    /** Number of possible positions on Edwards Elliptical Curve 521 */
    private BigInteger R = BigInteger.TWO.pow(519).subtract(new BigInteger("337554763258501705789107630418782636071904961214051226618635150085779108655765"));


    // --- Constructors ---

    /**
     *
     * @param x x-coordinate of Elliptic curve
     * @param y y-coordinate of Elliptic curve
     */
    public E521(BigInteger x, BigInteger y){
        this.X = x;
        this.Y = y;
    }

    /**
     * Default Initialization Constructor, defined as (0,1).
     */
    public E521(){
        X = new BigInteger("0");
        Y = new BigInteger("1");
    }

    // --- Fetch Functions ---

    /** Returns E521 X-coordinate */
    public BigInteger getX(){
        return X;
    }
    /** Returns E521 Y-coordinate */
    public BigInteger getY(){
        return Y;
    }

    /** Returns # of Possible E521 points */
    public BigInteger getR() { return R; }

    /** Replaces E521 X-coordinate */
    public void setX(BigInteger tempX){
        this.X = tempX;
    }

    /** Replaces E521 Y-coordinate */
    public void setY(BigInteger tempY){
        this.Y = tempY;
    }

    // --- Support Functions ---

    /**
     * Equal Function determining if two E521 points
     *
     * @param that E521 point to be compared against
     * @return boolean dependent on if the E521 points were a direct match
     */
    public boolean equals(E521 that){
        return this.getX().equals(that.getX()) && this.getY().equals(that.getY());
    }

    @Override
    public String toString(){
        return "X: " + X.toString() + "\nY: " + Y.toString();
    }

    // --- Main Mod Functions ---

    /**
     * Adds two Edward Elliptical Points returning a new point in the curve.
     * Result Generated by the use of the function: (x1, y1) + (x2, y2) = [(x1y2 + y1x2) / (1 + d * x1x2y1y2)], [(y1y2 - x1x2) / (1 - d* x1x2y1y2)]
     *
     * @param that E521 elliptic point to be added against
     * @return new E521 elliptic point
     */
    public E521 add( E521 that) {

        BigInteger xTop = this.X.multiply(that.getY()).add(this.Y.multiply(that.getX())).mod(P);
        BigInteger xBottom = BigInteger.ONE.add(this.D.multiply(this.X).multiply(that.getX()).multiply(this.Y).multiply(that.getY())).mod(P);


        BigInteger yTop = this.Y.multiply(that.getY()).subtract(this.X.multiply(that.getX())).mod(P);
        BigInteger yBottom = BigInteger.ONE.subtract(this.D.multiply(this.X).multiply(that.getX()).multiply(this.Y).multiply(that.getY())).mod(P);

        return new E521( xTop.multiply(xBottom.modInverse(P)).mod(P) , yTop.multiply(yBottom.modInverse(P)).mod(P) );
    }

    /**
     * Multiplication Function given (__P__ * __E521__)
     *
     * @param P Number of instances for which __P__ will add up coords against itself
     * @return new elliptic point for which result of multiplication
     */
    public E521 multiply( BigInteger P ){
        E521 result = new E521();
        BigInteger count = BigInteger.ZERO;
        while(!count.equals(P)){
            result = result.add(this);
            count.add(BigInteger.ONE);
        }
        return result;
    }

    /**
     * Returns elliptic curve point with x-coordinate negated
     *
     * @return E521 with x-coordinate negated
     */
    public E521 oppositeX() {
        return new E521(getX().negate(), getY());
    }

    // public doubleAndAdd(BigInteger S)
    // Montgomery multiply


    /**
     * Square root function for which (__rad__ mod __mval__) while satisfying Least Significant Bit required input
     *
     * @param rad radicand
     * @param mval modulus for which (m mod 4 = 3) must be maintained
     * @param lsb insures the Least Significant Bit value where (true = 1, false = 0)
     * @return Function returns root given (__rad__ mod __mval__) with the root mod 2 = 1
     * when __lsb__ = true if the root exists. If not satisfied function returns NULL;
     */
    public static BigInteger sqrt(BigInteger rad, BigInteger mval, boolean lsb) {
        assert (mval.testBit(0) && mval.testBit(1));
        BigInteger root = rad.modPow(mval.shiftRight(2).add(BigInteger.ONE), mval);

        if (rad.signum() == 0) {
            return BigInteger.ZERO;
        }
        else if (root.testBit(0) != lsb) {
            root = mval.subtract(root);
        }
        else if(root.multiply(root).subtract(rad).mod(mval).signum() == 0) {
            return root;
        }
        return null;
    }

}
